using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Kazetta.ViewModel
{
	/// <summary>
	/// Because this is not an enterprise app, I didn't create the plumbing necessary to have separate ViewModels for each tab.
	/// Instead I dumped all of the application state in the below class.
	/// </summary>
	public class MainWindow : ViewModelBase
	{
		/// <summary>
		/// Most tabs disable if this is false
		/// </summary>
		public bool PeopleNotEmpty => Students.Any();

		private bool magicAllowed = true;
		private bool magicPossible = false;
		public bool MagicAllowed { get => magicAllowed; set { magicAllowed = value; RaisePropertyChanged("MagicEnabled"); } }
		public bool MagicPossible { get => magicPossible; set { magicPossible = value; RaisePropertyChanged(); RaisePropertyChanged("MagicEnabled"); } }
		public bool MagicEnabled => MagicAllowed && MagicPossible;

		public bool AdvancedGuitarists { get; set; }

		private void People_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
		{
			RaisePropertyChanged("PeopleNotEmpty");
			RaisePropertyChanged("Students");
		}

		private ObservableCollection2<Student> students;
		public ObservableCollection2<Student> Students
		{
			get
			{
				if (students == null)
				{
					students = new ObservableCollection2<Student>();
					students.CollectionChanged += People_CollectionChanged;
				}
				return students;
			}
			private set
			{
				students = value;
				RaisePropertyChanged();
				RaisePropertyChanged("PeopleNotEmpty");
			}
		}

		private ObservableCollection2<Teacher> teachers;
		public ObservableCollection2<Teacher> Teachers
		{
			get
			{
				if (teachers == null)
				{
					teachers = new ObservableCollection2<Teacher>(new Teacher[21]);
					teachers.CollectionChanged += People_CollectionChanged;
				}
				return teachers;
			}
			private set
			{
				teachers = value;
				RaisePropertyChanged();
			}
		}


		private List<ObservableCollection2<Group>> _schedule = new List<ObservableCollection2<Group>>();
		public List<ObservableCollection2<Group>> Schedule
		{
			get => _schedule;
			private set
			{
				_schedule = value;
				RaisePropertyChanged();
			}
		}

		private volatile bool scheduleInited = false;

		/// <summary>
		/// This method is called when the ScheduleTab tab is opened and all conditions have been met.
		/// </summary>
		internal void InitSchedule()
		{
			if (scheduleInited)
				return;
			foreach (var t in Teachers)
			{
				var students = Students.Where(p => p.Teacher == t || p.VocalTeacher == t).ToList();
				Group[] groups = new Group[7];
				for (int i = 0; i < 7; i++)
				{
					groups[i] = new Group { Persons = students.Where(p => (p.Teacher == t && p.TimeSlot == i) || (p.VocalTeacher == t && p.VocalTimeSlot == i)).ToArray() };
					if (groups[i].Persons.Length > 2)
						throw new Exception(groups[i].Persons.Length + " ember nem lehet egy csoportban");
					groups[i].CreateSubscriptions();
				}
				Schedule.Add(new ObservableCollection2<Group>(groups));
			}

			scheduleInited = true;
		}


		internal void InitGroups()
		{
			Groups.AddRange(Students.Select(s =>
			{
				var g = new Group { Persons = new Student[] { s }, Autogenerated = true };
				g.CreateSubscriptions();
				return g;
			}));
		}

		public ICollectionView GroupEligible => CollectionViewHelper.Lazy<Student>(Students, p => p.Group == null && p.Instrument == Instrument.Solo);
		public ICollectionView Unscheduled => CollectionViewHelper.Lazy<Group>(Groups, g => g.Unscheduled);

		private ObservableCollection2<Group> groups;
		public ObservableCollection2<Group> Groups
		{
			get => groups ?? (groups = new ObservableCollection2<Group>());
			private set { groups = value; RaisePropertyChanged(); }
		}

		public ICollectionView UserGroups => CollectionViewHelper.Lazy<Group>(Groups, g => !((Group)g).Autogenerated);

		private Group newGroup;
		public Group NewGroup
		{
			get => newGroup ?? (newGroup = new Group { Autogenerated = false, Persons = new Student[3] });
			set { newGroup = value; RaisePropertyChanged(); }
		}

		public Algorithms Algorithm { get; set; }
		private string statusText = "";

		public string StatusText
		{
			get => statusText;
			set { statusText = value; RaisePropertyChanged(); }
		}

		internal AppData AppData
		{
			get => new AppData
			{
				Students = Students.ToArray(),
				Teachers = Teachers.ToArray(),
				Groups = Groups.ToArray()
			};
			set
			{
				Students.AddRange(value.Students);
				Teachers.QuietClear();
				Teachers.AddRange(value.Teachers);
				Groups.AddRange(value.Groups);
				// The XML serializer doesn't handle object references, so we replace Person copies with references
				foreach (Student student in Students)
				{
					if (student.Teacher != null)
						student.Teacher = Teachers.Single(p => p.Name == student.Teacher.Name);
					if (student.VocalTeacher != null)
						student.VocalTeacher = Teachers.Single(p => p.Name == student.VocalTeacher.Name);
					for (int i = 0; i < 2; i++)
						if (student.PreferredVocalTeachers[i] != null)
							student.PreferredVocalTeachers[i] = Teachers.Single(p => p.Name == student.PreferredVocalTeachers[i].Name);
				}
				foreach (Group group in Groups)
				{
					for (int i = 0; i < group.Persons.Length; i++)
					{
						group.Persons[i] = Students.Single(p => p.Name == group.Persons[i].Name);
						group.Persons[i].Group = group;
                    }
					
					group.CreateSubscriptions();
				}
			}
		}

		public bool CanAssign(Group g, Teacher teacher)
		{
			Student p = g.Persons[0];
			if (teacher.Name == "Vadász Gellért")
				return false; // his schedule will be derived from Ági's
			if (g.Persons.Length == 2)
				return teacher.Instruments.Contains(p.Instrument);
			else if (p.Group != null)
				return p.IsVocalistToo && teacher.IsVocalist;
			else return teacher.Instruments.Contains(p.Instrument) || p.IsVocalistToo && teacher.IsVocalist;
		}

		public bool CanAssign(Group g, int teacherIndex, int timeSlot)
		{
			var ret = CanAssign(g, Teachers[teacherIndex]) 
				&& !g.Persons.Any(p => p.TimeSlot == timeSlot || p.VocalTimeSlot == timeSlot)
				&& !Schedule[teacherIndex][timeSlot].Persons.Any();

			if (Teachers[teacherIndex].IsVocalist && g.Persons.Any(p => p.Instrument == Instrument.Solo))
			{// we are trying to assign a soloist to their vocal teacher: check that the proposed timeslot does not conflict with their improv lesson
				ret = ret && !g.Persons.Any(p => timeSlot == (p.TimeSlot + 1) % 7);
			}
			else if (Teachers[teacherIndex].Instruments.Contains(Instrument.Solo))
			{// we are trying to assign a group to the solfeggio teacher at timeSlot; check that the next timeslot is also free for both of them
				ret = ret && !g.Persons.Any(p => p.TimeSlot == (timeSlot + 1) % 7 || p.VocalTimeSlot == (timeSlot + 1) % 7);
			}

			return ret;
		}

		public void AssignTo(Group g, int teacherIndex, int timeSlot, bool overrideTimeSlot = false)
		{
			AssignTo(g, null, Schedule[teacherIndex], Teachers[teacherIndex], 0, timeSlot, overrideTimeSlot);
		}

		public void AssignTo(Group g,
			ObservableCollection2<Group> sourceCollection,
			ObservableCollection2<Group> targetCollection,
			Teacher targetTeacher,
			int sourceIndex,
			int targetIndex,
			bool overrideTimeslot)
		{
			int i = targetIndex;
			var p = g.Persons[0];

			if (targetTeacher.Instruments.Contains(p.Instrument))
			{
				if (p.Teacher != null)
					sourceCollection[sourceIndex] = new Group();
				foreach (var q in g.Persons)
				{
					q.TimeSlot = i;
					q.Teacher = targetTeacher;

					if (overrideTimeslot && q.VocalTimeSlot == i)
					{
						int j = Teachers.IndexOf(q.VocalTeacher);
						q.VocalTeacher = null;
						if (j >= 0)
							Schedule[j][i] = new Group();
					}
				}
			}
			else if (p.IsVocalistToo && targetTeacher.IsVocalist)
			{
				if (p.VocalTeacher != null)
					sourceCollection[sourceIndex] = new Group();
				p.VocalTimeSlot = i;
				p.VocalTeacher = targetTeacher;

				if (overrideTimeslot && p.TimeSlot == i)
				{
					int j = Teachers.IndexOf(p.Teacher);
					p.Teacher = null;
					if (p.Group != null)
					{
						foreach (Student student in p.Group.Persons)
						{
							student.Teacher = null;
						}
					}
					if (j >= 0)
						Schedule[j][i] = new Group();
				}
			}
			else return;

			targetCollection[targetIndex % targetCollection.Count] = g;
		}

		public void ClearSchedule()
		{
			foreach (Student p in Students)
			{
				p.Teacher = p.VocalTeacher = null;
				p.TimeSlot = p.VocalTimeSlot = -1;
			}
			foreach (var coll in Schedule)
			{
				coll.Clear();
				coll.AddRange(Enumerable.Range(0, 7).Select(_ => new Group()));
			}
		}

		public void AddGroup(Group group)
		{
			var p = group.Persons;
			Groups.RemoveAll(g => g.Autogenerated && g.Persons.Length == 1 && !g.Persons[0].IsVocalistToo && p.Contains(g.Persons[0]));
			group.CreateSubscriptions();
			Groups.Add(group);
			foreach (Student student in group.Persons)
			{
				student.Group = group;
			}
		}
	}
}